webpackJsonp([82774138702190],{329:function(e,o){e.exports={data:{markdownRemark:{html:'<h1>Build and deploy a quick Rails app to Heroku</h1>\n<p>Building and deploying a Rails app to Heroku is actually pretty fast.</p>\n<p>Start by running:</p>\n<pre><code class="language-ruby">rails new basic_app\n</code></pre>\n<p>After starting the server with <code>rails server -b 0.0.0.0 -p 3000</code>, you should see the default Rails "Welcome" screen.</p>\n<p>Now generate a controller:</p>\n<pre><code class="language-ruby">rails generate controller home\n</code></pre>\n<p>And inside of <code>config/routes.rb</code>:</p>\n<pre><code class="language-ruby">Rails.application.routes.draw do\n  root \'home#index\'\nend\n</code></pre>\n<p>Create a new file <code>app/views/home/index.html.erb</code>, and add a headline:</p>\n<pre><code class="language-ruby">&#x3C;h1>Here\'s a headline.&#x3C;/h1>\n</code></pre>\n<p>We can set some styles in <code>app/assets/stylesheets/home.scss</code></p>\n<pre><code class="language-css">h1 {\n  color: rebeccapurple;\n}\n</code></pre>\n<p>Restart the Rails server, and you should see the headline.</p>\n<p>Push it to github!</p>\n<h1>Deploying to Heroku</h1>\n<p>Create a new Heroku app:</p>\n<pre><code class="language-ruby">heroku create tayiorbeii-basic-app\n</code></pre>\n<p>Then do:</p>\n<pre><code class="language-ruby">git push heroku master\n</code></pre>\n<p><em>I actually got an error here.</em></p>\n<p>Heroku complained about the <code>sqlite3</code> gem not being supported by Heroku, so I\'m going to remove it from the <code>Gemfile</code> and try to push again.</p>\n<p>So I removed it, pushed again, but it complained that I have to run <code>bundle install</code> to clean up the lockfile.</p>\n<p>Probably should have just used <code>rails new basic_app --database=postgresql</code> when creating the app.</p>\n<p>Update the Gemfile to use <code>pg</code>:</p>\n<pre><code class="language-ruby"># Use postgresql as the database for Active Record\ngem \'pg\'\n</code></pre>\n<p>Run <code>bundle install</code> then push to git &#x26; Heroku, and still complaining.</p>\n<p>Ends up there\'s more references to <code>sqlite3</code> in the <code>config/database.yml</code> file.</p>\n<p>Push it up, and all is well with the universe!</p>',frontmatter:{title:"Build and deploy a quick Rails app to Heroku",date:"December 06, 2017",path:"/basic-rails-app",tags:["ruby","rails","heroku","code"],excerpt:""}}},pathContext:{next:{html:'<ul>\n<li>1 Cup of quinoa, rinsed</li>\n<li>1/2 Cup of El Pato Salsa (about half the can)</li>\n<li>1/2 Cup of water</li>\n<li>Handful of frozen corn</li>\n<li>Handful of <em>cooked</em> black beans (from can or homemade)</li>\n<li>Salt, maybe some cumin</li>\n</ul>\n<h4>Instructions</h4>\n<p>Put Instant Pot in sautee mode. Dump the quinoa into the pot, no liquid, and stir it up until it smells toasty. Add the sauce, water, and corn and beans if you want.</p>\n<p>Seal the Instant Pot, and do high pressure for 1 minute.</p>\n<p>When it beeps, hit cancel to turn off "Keep Warm" mode, and wait for pressure to drop so you can open the lid, add salt &#x26; cumin as desired, and eat it!</p>',id:"/Users/taylor/Documents/Projects/taylorlistens/src/pages/2017-12-15-instant-pot-mexican-quinoa/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-12-15T15:39:10.752Z",path:"/instant-pot-mexican-quinoa",title:"Instant Pot Mexican Quinoa",excerpt:null,tags:["instant pot","recipe"]}},prev:{html:"<h3>Creating a UserDashboard Store</h3>\n<p>First I created <code>userDashboardStore.js</code> inside of the <code>state</code> directory. For the time being, I've only added one <code>@observable</code> inside of the class:</p>\n<pre><code class=\"language-javascript\">export default class UserDashboardStore {\n  @observable testString = 'mobx here'\n}\n</code></pre>\n<p>Then following the pattern of the other stores, I added <code>userDashboardStore</code> entries to <code>state/appStore.js</code>.</p>\n<h3>Injecting into the <code>UserDashboard</code> Screen</h3>\n<p>In the <code>UserDashboard</code> screen, I imported <code>observer</code> and <code>inject</code> from <code>mobx-react</code>. </p>\n<p>However, I ran into an error that <code>Store userDashboardStore is not available</code> and needs to be provided by a <code>Provider</code>...</p>\n<p>I'll come back to this.</p>\n<h3>Adding <code>userDashboardStore</code> to a <code>Provider</code></h3>\n<p>First I tried adding a <code>&#x3C;Route></code> for <code>UserContentDashboardRoutes</code> following the pattern as seen in <code>client/app/routes/index.js</code> but the error remained.</p>\n<p>Then I tried just having <code>ComponentDevRoutes</code> since it's a level up, but that didn't work either.</p>\n<p>Then I remembered that <code>ComponentDev</code> has its own <code>&#x3C;Provider></code>, so I added the <code>UserDashboardStore</code> stuff there instead:</p>\n<pre><code class=\"language-javascript\">import UserContentDashboard from '../../UserContentDashboard/screens/UserContentDashboard'\n...\nconst userDashboardStore = new UserDashboardStore()\n...\n&#x3C;Provider currentUserStore={currentUserStore} userDashboardStore={userDashboardStore}>\n</code></pre>\n<p>The error is fixed!</p>\n<h3>Back to Injecting the Store</h3>\n<p>After importing <code>inject</code> and <code>observer</code> from <code>mobx-react</code> I realize that I need to convert the screen into a <code>class</code> instead of a stateless functional component. So I do that, and then I'm able to access my <code>testString</code> from <code>UserDashboardStore</code>!</p>\n<p>...but my <code>currentUserStore</code> is empty.</p>\n<h3>Filling up <code>currentUserStore</code></h3>\n<p>In <code>ComponentDev</code>'s routes, there is a <code>render</code> prop that was just returning <code>&#x3C;UserContentDashboard /></code>. I changed the arrow function from using parens to using brackets, in order to be able to call <code>currentUserStore.loadUser()</code> first:</p>\n<pre><code class=\"language-javascript\">&#x3C;Route\n exact\n path='/user_dashboard'\n render={routeProps => {\n             currentUserStore.loadUser()\n             return &#x3C;UserContentDashboard {...props} {...routeProps} />\n            }}\n/>\n</code></pre>\n<p>Now I'm able to access info about the current user!</p>\n<h3>Updating <code>UserContentDashboard</code></h3>\n<ul>\n<li>Instead of a hardcoded <code>userId</code>, I use lodash's <code>get</code> to access <code>currentUserStore.currentUser.id</code>, which is then used for <code>&#x3C;Request></code>ing from the <code>user_content_dashboard</code> endpoint.</li>\n</ul>\n<h3>Adding Observables to the <code>UserDashboardStore</code></h3>\n<p>Looking at Ian's example of how he's integrated MobX into the Instructors screen, I created <code>@observable</code>s for each of the lists on the Dashboard:</p>\n<pre><code class=\"language-javascript\">  @observable inProgressContent = []\n  @observable latestLessons = []\n  @observable recommendedCourses = []\n  @observable recommendedLessons = []\n  @observable inProductionContent = []\n</code></pre>\n<p>I also added a <code>constructor</code> as seen in the <code>LessonScreenStore</code>, and updated the <code>ComponentDev</code> routes to pass <code>appStore</code> to <code>UserDashboardStore</code></p>\n<pre><code class=\"language-javascript\">const userDashboardStore = new UserDashboardStore(appStore)\n</code></pre>",id:"/Users/taylor/Documents/Projects/taylorlistens/src/pages/2017-09-20-mobx-learning/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-09-20T16:54:15.752Z",path:"/mobx-learning",title:"Mobx Learning",excerpt:"In which I wire a screen up to MobX",tags:["react","mobx"]}}}}}});
//# sourceMappingURL=path---basic-rails-app-cb7bdf10a5e5c4322644.js.map