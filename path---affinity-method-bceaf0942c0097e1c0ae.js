webpackJsonp([97121766385102],{372:function(e,o){e.exports={data:{markdownRemark:{html:"<h1>My Affinity Method</h1>\n<p>When performing research via surveys, it can be tricky to categorize free text responses.</p>\n<p>One of the most useful techniques I've developed follows the general proceedure of <a href=\"http://asq.org/learn-about-quality/idea-creation-tools/overview/affinity.html\">creating an Affinity Diagram</a>.</p>\n<h3>Three Rules</h3>\n<ul>\n<li><strong>Do NOT make category assumptions</strong>. It doesn't matter if you <em>know</em> what the themes will be.</li>\n<li><strong>Record an ID to get back to a response</strong>. It saves a lot of time and headaches to record a unique ID (or email address or something) so you can find a person later for following up.</li>\n<li><strong>Do NOT group your groups until you're done processing</strong>. It doesn't take that long to do, which is all the more reason to just wait until you've finished going through the raw data.</li>\n</ul>\n<h3>The Process</h3>\n<p><em>This process assumes you've loaded up a bunch of raw survey data into some flavor of spreadsheet app.</em></p>\n<p><strong>Step 1: Set Up Column Focus</strong></p>\n<ul>\n<li>Decide which freeform response you are going to categorize, and hide every column except for the question and an identifier column (UUID, email address, or generate your own).</li>\n<li>Sort the responses in reverse alphabetical (<code>Z-A</code>, yeah) order. Now you don't have to scroll past a bunch of empty cells to get to words.</li>\n</ul>\n<p><strong>Step 2: Start a New Blank Spreadsheet Workbook Thing</strong>\nThis new sheet will be where the categorization happens. I tend to throw everything into a single sheet, and then add additional sheets as needed (the tabs on the bottom when looking at Google Drive).</p>\n<p>The first row will contain headers for each of the general themes that will emrge. Each header should have two columns between them, because the data rows will have some text and the identifier.</p>\n<p><strong>Step 3: Initial Reading &#x26; Classification</strong>\nMove down, row-by-row, and read the responses. Find the theme(s) of the text, and record some or all of the text under the appropriate column, along with the unique id so that you can find the response later.</p>\n<p>Here's an example:</p>\n<p><em>The pizza was great! I love all the unique topping choices, and the music was rad. The ponly thing is that the kid working the register was a little rude.</em></p>\n<pre><code>| Toppings        |    |   | Music               |    |   | Staff |    |\n|-----------------|----|---|---------------------|----|---|-------|----|\n| Loved selection | id |   | \"the music was rad\" | id |   | Rude  | id |\n|                 |    |   |                     |    |   |       |    |\n</code></pre>\n<p><strong>Step 4: Summarization</strong>\nAfter breaking responses into groups, it becomes easier to quantify the qualitative data. You could split each theme into positive &#x26; negative, or take it further and group respondents in one theme by answers to another question to find other insights.</p>",frontmatter:{title:"My Affinity Chart Method",date:"December 19, 2017",path:"/affinity-method",tags:["research"],excerpt:null}}},pathContext:{next:{html:'<h1>Learning some ActiveRecord</h1>\n<p>My goal here is to create a database seeded by some csv files, so I can ask questions of my data.</p>\n<p><strong>NOTE:</strong> This is a play-by-play of what I\'m doing as I do it, and is NOT in step-by-step, "follow along at home" format. I make mistakes here, and then work on fixing them!</p>\n<h3>Scaffolding an app</h3>\n<p>A scaffold is a full set of model, database migratioin, controller, view, and test suite.</p>\n<pre><code class="language-ruby">rails new basketball_model --database=postgresql\n\nrails generate scaffold Prediction home:string away:string ...\n\nrake db:create\n</code></pre>\n<hr>\n<h3>Associating Tables</h3>\n<p>Following through <a href="http://guides.rubyonrails.org/association_basics.html">Rails Guides\' Associations info</a>, My goal is to build something like this structure:</p>\n<ul>\n<li>\n<p><code>Team</code></p>\n<ul>\n<li><code>team_id</code></li>\n<li><code>team_name</code></li>\n<li><code>team_abbv</code></li>\n<li><code>team_city</code></li>\n<li><code>has_many</code> of each odds through each <code>Match</code></li>\n<li><code>has_many</code> <code>Match</code>es</li>\n</ul>\n</li>\n<li>\n<p><code>Match</code></p>\n<ul>\n<li><code>has_many</code> <code>Team</code>s</li>\n<li><code>has_one</code> <code>MoneyLineOdd</code> etc.</li>\n<li><code>has_many</code> <code>Prediction</code>s</li>\n<li><code>match_id</code></li>\n<li><code>date</code> datetime</li>\n<li><code>home_team_id</code></li>\n<li><code>away_team_id</code></li>\n<li><code>home_score</code></li>\n<li><code>away_score</code></li>\n<li><code>home_fave</code> boolean</li>\n<li><code>away_fave</code> boolean</li>\n<li><code>home_dog</code> boolean</li>\n<li><code>away_dog</code> boolean</li>\n</ul>\n</li>\n<li>\n<p><code>MoneyLineOdd</code></p>\n<ul>\n<li><code>belongs_to</code> <code>Match</code></li>\n<li><code>moneyline_id</code></li>\n<li><code>home_closing_odd</code></li>\n<li><code>away_closing_odd</code></li>\n<li><code>home_opening_odd</code></li>\n<li><code>away_opening_odd</code></li>\n</ul>\n</li>\n<li>\n<p><code>SpreadOdd</code></p>\n<ul>\n<li><code>belongs_to</code> <code>Match</code></li>\n<li><code>spread_id</code></li>\n<li><code>home_closing_odd</code></li>\n<li><code>away_closing_odd</code></li>\n<li><code>home_opening_odd</code></li>\n<li><code>away_opening_odd</code></li>\n<li><code>home_closing_value</code></li>\n<li><code>away_closing_value</code></li>\n<li><code>home_opening_value</code></li>\n<li><code>away_opening_value</code></li>\n</ul>\n</li>\n<li>\n<p><code>TotalOdd</code></p>\n<ul>\n<li><code>belongs_to</code> <code>Match</code></li>\n<li><code>total_id</code></li>\n<li><code>over_closing_odd</code></li>\n<li><code>under_closing_odd</code></li>\n<li><code>over_opening_odd</code></li>\n<li><code>under_opening_odd</code></li>\n<li><code>over_closing_value</code></li>\n<li><code>under_closing_value</code></li>\n<li><code>over_opening_value</code></li>\n<li><code>under_opening_value</code></li>\n</ul>\n</li>\n<li>\n<p><code>Prediction</code></p>\n<ul>\n<li><code>belongs_to</code> <code>Match</code></li>\n<li><code>prediction_id</code></li>\n<li><code>pred_type</code></li>\n<li><code>home_pred</code></li>\n<li><code>away_pred</code></li>\n<li><code>over_pred</code></li>\n<li><code>under_pred</code></li>\n</ul>\n</li>\n</ul>\n<p>With all of that schema stuff written out (which actually took quite a while to reason about...) I am going to try to generate scaffolding using info from <a href="https://stackoverflow.com/questions/39810917/generate-scaffold-which-references-a-model-who-refers-another-model">this StackOverflow question</a></p>\n<pre><code>rails g scaffold team id:integer name:string abbv:string city:string --no-stylesheets\n\nrails g scaffold match date:datetime home_team_id:references{polymorphic} away_team_id:references{polymorphic} home_fave:boolean away_fave:boolean home_dog:boolean away_dog:boolean --no-stylesheets\n\nrails g scaffold SpreadOdd home_opening_odd:float home_closing_odd:float away_opening_odd:float away_closing_odd:float home_opening_value:float away_opening_value:float home_closing_value:float away_closing_value:float --no-stylesheets\n\nrails g scaffold TotalOdd over_opening_odd:float over_closing_odd:float under_opening_odd:float under_closing_odd:float over_opening_value:float under_opening_value:float over_closing_value:float under_closing_value:float --no-stylesheets\n\nrails g scaffold Prediction pred_type:string home_pred:float away_pred:float over_pred:float under_pred:float --no-stylesheets\n</code></pre>\n<p>I forgot to add <code>home_id</code> and <code>away_id</code> to the Match table, so I had to rollback the database migration:</p>\n<pre><code class="language-ruby">rake db:rollback STEP=1\n</code></pre>\n<p>Then I generated a new migration:</p>\n<pre><code class="language-ruby">rails generate migration add_homeId_to_match\n</code></pre>\n<p>Updated the migration to add the foreign keys:</p>\n<pre><code class="language-ruby">class AddHomeIdToMatch &#x3C; ActiveRecord::Migration[5.0]\n  def change\n    create_table :matches do |t|\n      t.integer :home_id, foreign_key: true\n      t.integer :away_id, foreign_key: true\n    end\n  end\nend\n</code></pre>\n<p>and ran <code>rake db:migrate</code></p>\n<p><em>Big up to Rose and Nick for helping me figure out this part.</em></p>\n<p>Now to run a similar process for <code>Team</code> to add <code>matches</code> and <code>odds</code>, except doing it on one line like I could have the first time:</p>\n<pre><code class="language-ruby">rails generate migration addMatchesToTeams home_matches:references away_matches:references\n</code></pre>\n<pre><code class="language-ruby">class AddMatchesToTeams &#x3C; ActiveRecord::Migration[5.0]\n  def change\n    add_reference :teams, :home_matches, foreign_key: true\n    add_reference :teams, :away_matches, foreign_key: true\n  end\nend\n</code></pre>\n<p>Then I create a new <code>MatchTeams</code> table in order to link the <code>Team</code>s and <code>Match</code>es together.</p>\n<hr>\n<p>Now I\'m going to try following the instructions for the <a href="https://github.com/michaelnera/active_record_importer">ActiveRecordImporter gem</a>. </p>\n<p>I added <code>acts_as_importable</code> to <code>models/prediction.rb</code>.</p>\n<p>Then I found the syntax to find every CSV file in the directory I was working with (remembering that each file\'s header columns are part of the model I scaffolded):</p>\n<pre><code class="language-ruby">Dir.glob(\'path/to/files/*.rb\') do |csv_file|\n  Prediction.import!(file: File.open(csv_file))\nend\n</code></pre>\n<p>Judging from the amount of text that flew by, I think it worked!</p>\n<p>Visiting <code>http://localhost:3000/predictions</code>, I can see it didn\'t quite work-- my CSVs were using camelCase, and I set up my model to look for snake_case.</p>\n<p>I did <code>rake db:rollback STEP=1</code> to drop my table.</p>\n<p>Instead of redoing my migration file to camelCase, I used <code>sed</code> to globally rename the headers for each of the CSV files I\'m using as source material:</p>\n<p>In the CSV directory:\n<code>sed -i -- \'s/headerName/header_name/g\' *</code></p>\n<p>It worked, except it created a bunch of weird filenames with a bunch of dashes, so I probably shouldn\'t have used this <em>exact</em> <code>sed</code> command.</p>\n<p>So I ran <code>rake db:migrate</code> again, then the same <code>Dir.glob</code> command stuff in the rails console.</p>\n<p>Running <code>rails server</code> again, I can see the CSV data I imported!</p>\n<h2>Querying Data</h2>\n<p>Now that I\'ve got my data in a database, I need to learn how to query it. I\'m reading through the <a href="http://guides.rubyonrails.org/active_record_querying.html">Query Guides</a>.</p>\n<p>After some experimentation in the rails console, I found that I could select entries with a query like this:</p>\n<pre><code class="language-ruby">std_overs = Prediction.where("std_home_pred + std_away_pred > ou")\n</code></pre>\n<p>Now the <code>std_overs</code> is an <code>ActiveRecord::Relation</code>.</p>\n<p>This means I can do this in the console to play around:</p>\n<pre><code class="language-ruby">std_over_wins = std_overs.where("ou_result = \'O\'")\nstd_over_losses = std_overs.where("ou_result = \'U\'")\n\nstd_over_diff_10_wins = std_over_wins.where("(std_home_pred + std_away_pred - ou) >= 10")\n</code></pre>\n<h2>Creating other Tables</h2>',id:"/Users/taylor/Documents/Projects/taylorlistens/src/pages/2017-12-27-learning-some-activerecord/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-12-28T02:18:29.004Z",path:"/learning-some-activerecord",title:"Learning Some ActiveRecord",excerpt:null,tags:["rails","ruby","activerecord"]}},prev:{html:"<h1>First Attempt</h1>\n<ul>\n<li>2 heaping cups of dried pinto beans (~1 pound)</li>\n</ul>\n<p>Soak them overnight. If I think about it, I change the water once.</p>\n<p>The next day, dump the beans in the pot and fill with water until they're covered by a couple inches. I dash in some hot sauce and some salt.</p>\n<p>Cook on high pressure for 12 minutes.</p>\n<p>When it's done, do a natural pressure release for 12 minutes, then quick release the rest.</p>\n<p>When they were done, drain them, then add them back to the pot with some spices (cumin, salt, pepper) and mash them up.</p>\n<p><em>Verdict:</em> Cook them a little bit longer next time, maybe 14 minutes... there were still a few harder ones left.</p>",id:"/Users/taylor/Documents/Projects/taylorlistens/src/pages/2017-12-15-instant-pot-refried-beans/index.md absPath of file >>> MarkdownRemark",frontmatter:{date:"2017-12-15T18:40:33.796Z",path:"/instant-pot-refried-beans",title:"Instant Pot Refried Beans",excerpt:"",tags:["instant pot","recipe"]}}}}}});
//# sourceMappingURL=path---affinity-method-bceaf0942c0097e1c0ae.js.map